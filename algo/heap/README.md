## 堆(heap)

### 1 heap-概念
#### 1.1 堆的概念
一种特殊的树，满足下面两个条件：

1. 堆总是一棵完全二叉树（除了最后一层，其他都是满节点，最右一层先排左节点）

2. 堆中某个节点的值总是大于等于（小于等于）其所有子节点的值。如果是大于等于情况就称为
大顶堆，小于等于情况就是小顶堆。完全二叉树适合用数组存储，因为下标为 i 的元素，
它的左子树下标为 2i, 右子树下标为 2i+1。父节点就是 i/2 的 overflow。


#### 1.2 建堆
堆是用数组存储的，而且 0 下标不存，从 1 开始存储，建堆就是在原地通过交换位置，
达到建堆的目的。完全二叉树我们知道，如果最后一个元素的下标为 n, 则 1 到 n/2 是
非叶子节点，需要自上而下的堆化（和子节点比较），n/2 +1 到 n 是叶子节点，不需要堆化。

#### 1.3 插入元素
先插入的元素放到堆最后，然后和父节点比较，如果大于父节点，就交换位置，
然后再和父节点比较，直到把这个元素放到正确的层。这种也叫自下而上的堆化。

#### 1.4 删除元素
假如删除大顶堆的，删除最大的元素，然后再它的子节点找到第二大元素，放到堆顶。
然后再第二大元素下一层寻找

### 2 堆的应用

#### 2.1 优先级队列

#### 2.2 用堆求 Top K（就是从一堆数据中找出前 k 大的数据）
#### 2.3 海量关键词搜索记录，求搜索次数 topK

### 3 Go实现堆
#### 3.1 go实现之小顶堆
小顶堆使用golang的切片进行存储，需要满足一下性质

- 根节点是整个堆最小的节点
- 每个节点都不大于左右子节点
- 加入和删除节点后仍然保持前两个性质

大致思路如下：
- 对于每一个元素存储再切片的索引index
- 左右子节点对应的索引为 2*index+1 和 2*index+2
- 父节点对应索引位置为 (index-1)/2

实现一个堆，主要实现两种方法 sink 和swim
- sink: 让堆中的元素通过递归的与自己的左右子节点比较下沉到合适的位置。
- swim: 让堆中的元素递归的与自己的根节点比较从而上浮到合适的位置。

如何保证堆在变化时候维持原有性质?
- push操作：在数据添加到切片末尾，对该元素进行swim操作，使改元素上浮到正确的位置
- pop操作：将堆顶元素和堆尾元素交换，把堆尾元素弹出（即为所需要的最小的元素），同时对新的堆顶元素执行 sink 操作，使得元素重新下沉到正确位置
#### 3.2 go实现之大顶堆





